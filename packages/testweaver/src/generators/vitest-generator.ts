/**
 * Vitest Generator
 *
 * Generates Vitest + React Testing Library test files from IR TestSuite objects.
 */

import type {
  TestSuite,
  TestCase,
  TestStep,
  TestExpectation,
  Selector,
} from "../types/ir.js";

/**
 * Auto-generated file header comment
 */
const HEADER = "// Auto-generated by TestWeaver. DO NOT EDIT.";

/**
 * Generates a file name for a test case
 * Format: context.scenario.test.tsx
 */
export function generateFileName(testCase: TestCase): string {
  const context = sanitizeFileName(testCase.context);
  const scenario = sanitizeFileName(testCase.scenario);
  return `${context}.${scenario}.test.tsx`;
}

/**
 * Sanitizes a string for use in a file name
 */
function sanitizeFileName(str: string): string {
  return str.replace(/[^a-zA-Z0-9-_]/g, "-").toLowerCase();
}

/**
 * Escapes a string for use in JavaScript string literals
 */
function escapeString(str: string): string {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

/**
 * Generates a selector expression for React Testing Library
 */
function generateSelector(selector: Selector): string {
  switch (selector.type) {
    case "testId":
      return `screen.getByTestId("${escapeString(selector.value)}")`;
    case "role":
      return `screen.getByRole("${escapeString(selector.value)}")`;
    case "labelText":
      return `screen.getByLabelText("${escapeString(selector.value)}")`;
    case "placeholder":
      return `screen.getByPlaceholderText("${escapeString(selector.value)}")`;
    case "css":
    case "custom":
    default:
      return `document.querySelector("${escapeString(selector.value)}")`;
  }
}

/**
 * Generates code for a single test step
 */
function generateStepCode(step: TestStep): string {
  const selectorExpr = generateSelector(step.selector);

  switch (step.action) {
    case "click":
      return `fireEvent.click(${selectorExpr});`;
    case "type":
    case "change": {
      const value =
        typeof step.value === "string" ? step.value : String(step.value ?? "");
      return `fireEvent.change(${selectorExpr}, { target: { value: "${escapeString(value)}" } });`;
    }
    case "focus":
      return `fireEvent.focus(${selectorExpr});`;
    case "blur":
      return `fireEvent.blur(${selectorExpr});`;
    case "key": {
      const key =
        typeof step.value === "string" ? step.value : String(step.value ?? "");
      return `fireEvent.keyDown(${selectorExpr}, { key: "${escapeString(key)}" });`;
    }
    case "waitFor":
      return `await waitFor(() => ${selectorExpr});`;
    case "submitContext":
      return `fireEvent.click(${selectorExpr});`;
    case "custom":
    default:
      return `// Custom step: ${String(step.value ?? step.action)}`;
  }
}

/**
 * Generates code for a single test expectation
 */
function generateExpectationCode(expectation: TestExpectation): string {
  if (expectation.selector === undefined) {
    // Handle URL assertions or other selector-less expectations
    switch (expectation.type) {
      case "url-contains":
        return `expect(window.location.href).toContain("${escapeString(String(expectation.value ?? ""))}");`;
      case "url-exact":
        return `expect(window.location.href).toBe("${escapeString(String(expectation.value ?? ""))}");`;
      default:
        return `// Expectation without selector: ${expectation.type}`;
    }
  }

  const selectorExpr = generateSelector(expectation.selector);
  const elementVar = `el_${expectation.id.replace(/-/g, "_")}`;

  switch (expectation.type) {
    case "visible":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toBeVisible();`;
    case "not-visible":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).not.toBeVisible();`;
    case "exists":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toBeInTheDocument();`;
    case "not-exists":
      return `expect(screen.queryByTestId("${escapeString(expectation.selector.value)}")).not.toBeInTheDocument();`;
    case "text":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toHaveTextContent("${escapeString(String(expectation.value ?? ""))}");`;
    case "exact-text":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toHaveTextContent(/^${escapeString(String(expectation.value ?? ""))}$/);`;
    case "value":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toHaveValue("${escapeString(String(expectation.value ?? ""))}");`;
    case "has-class":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toHaveClass("${escapeString(String(expectation.value ?? ""))}");`;
    case "not-has-class":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).not.toHaveClass("${escapeString(String(expectation.value ?? ""))}");`;
    case "aria":
      return `const ${elementVar} = ${selectorExpr};\n    expect(${elementVar}).toHaveAttribute("aria-${escapeString(String(expectation.value ?? ""))}");`;
    case "snapshot":
      return `expect(${selectorExpr}).toMatchSnapshot();`;
    case "custom":
    default:
      return `// Custom expectation: ${expectation.type}`;
  }
}

/**
 * Generates test code for a single TestCase
 */
function generateTestCaseCode(testCase: TestCase, indent: string): string {
  const lines: string[] = [];

  // Add steps
  if (testCase.steps.length > 0) {
    lines.push(`${indent}// Steps`);
    for (const step of testCase.steps) {
      lines.push(`${indent}${generateStepCode(step)}`);
    }
    lines.push("");
  }

  // Add expectations
  if (testCase.expectations.length > 0) {
    lines.push(`${indent}// Expectations`);
    for (const expectation of testCase.expectations) {
      lines.push(`${indent}${generateExpectationCode(expectation)}`);
    }
  }

  return lines.join("\n");
}

/**
 * Generates a complete Vitest test file from a TestSuite
 *
 * @param testSuite - The TestSuite to generate tests for
 * @returns The complete test file content as a string
 */
export function generateVitest(testSuite: TestSuite): string {
  const lines: string[] = [];

  // Add header
  lines.push(HEADER);
  lines.push("");

  // Add imports
  lines.push(
    'import { render, screen, fireEvent, waitFor } from "@testing-library/react";'
  );
  lines.push('import "@testing-library/jest-dom";');

  // Try to determine component import path from sourceFiles or meta
  const sourceFile = testSuite.sourceFiles[0];
  if (sourceFile !== undefined) {
    const componentName =
      testSuite.cases[0]?.meta?.componentName ?? getComponentNameFromPath(sourceFile.filePath);
    const importPath = testSuite.cases[0]?.meta?.importPath ?? sourceFile.filePath;

    if (componentName !== undefined) {
      lines.push(`import { ${componentName} } from "${importPath}";`);
    }
  }

  lines.push("");

  // Generate describe block
  lines.push(`describe("${escapeString(testSuite.context)}", () => {`);

  // Generate test cases
  for (const testCase of testSuite.cases) {
    lines.push(`  it("${escapeString(testCase.scenario)}", async () => {`);

    // Render component
    const componentName =
      testCase.meta?.componentName ??
      (sourceFile !== undefined ? getComponentNameFromPath(sourceFile.filePath) : "Component");

    if (componentName !== undefined) {
      lines.push(`    render(<${componentName} />);`);
    }

    lines.push("");

    // Add test code
    const testCode = generateTestCaseCode(testCase, "    ");
    if (testCode.trim().length > 0) {
      lines.push(testCode);
    }

    lines.push("  });");
    lines.push("");
  }

  lines.push("});");

  return lines.join("\n");
}

/**
 * Extracts a component name from a file path
 * E.g., "src/components/Login.tsx" â†’ "Login"
 */
function getComponentNameFromPath(filePath: string): string | undefined {
  const match = filePath.match(/([A-Z][a-zA-Z0-9]*)\.[jt]sx?$/);
  return match?.[1];
}
