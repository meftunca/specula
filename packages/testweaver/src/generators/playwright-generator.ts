/**
 * Playwright Generator
 *
 * Generates Playwright E2E test files from IR TestSuite objects.
 */

import type {
  TestSuite,
  TestCase,
  TestStep,
  TestExpectation,
  Selector,
} from "../types/ir.js";

/**
 * Auto-generated file header comment
 */
const HEADER = "// Auto-generated by TestWeaver. DO NOT EDIT.";

/**
 * Generates a file name for a test case
 * Format: context.scenario.spec.ts
 */
export function generateFileName(testCase: TestCase): string {
  const context = sanitizeFileName(testCase.context);
  const scenario = sanitizeFileName(testCase.scenario);
  return `${context}.${scenario}.spec.ts`;
}

/**
 * Sanitizes a string for use in a file name
 */
function sanitizeFileName(str: string): string {
  return str.replace(/[^a-zA-Z0-9-_]/g, "-").toLowerCase();
}

/**
 * Escapes a string for use in JavaScript string literals
 */
function escapeString(str: string): string {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

/**
 * Escapes a string for use in regex patterns
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/**
 * Generates a locator expression for Playwright
 */
function generateLocator(selector: Selector): string {
  switch (selector.type) {
    case "testId":
      return `page.locator('[data-test-id="${escapeString(selector.value)}"]')`;
    case "role":
      return `page.getByRole("${escapeString(selector.value)}")`;
    case "labelText":
      return `page.getByLabel("${escapeString(selector.value)}")`;
    case "placeholder":
      return `page.getByPlaceholder("${escapeString(selector.value)}")`;
    case "css":
    case "custom":
    default:
      return `page.locator("${escapeString(selector.value)}")`;
  }
}

/**
 * Generates code for a single test step
 */
function generateStepCode(step: TestStep): string {
  const locatorExpr = generateLocator(step.selector);

  switch (step.action) {
    case "click":
      return `await ${locatorExpr}.click();`;
    case "type":
    case "change": {
      const value =
        typeof step.value === "string" ? step.value : String(step.value ?? "");
      return `await ${locatorExpr}.fill("${escapeString(value)}");`;
    }
    case "focus":
      return `await ${locatorExpr}.focus();`;
    case "blur":
      return `await ${locatorExpr}.blur();`;
    case "key": {
      const key =
        typeof step.value === "string" ? step.value : String(step.value ?? "");
      return `await ${locatorExpr}.press("${escapeString(key)}");`;
    }
    case "select": {
      // Select action for dropdown/select elements
      const value =
        typeof step.value === "string" ? step.value : String(step.value ?? "");
      return `await ${locatorExpr}.selectOption("${escapeString(value)}");`;
    }
    case "hover":
      return `await ${locatorExpr}.hover();`;
    case "clear":
      return `await ${locatorExpr}.clear();`;
    case "waitFor":
      return `await ${locatorExpr}.waitFor();`;
    case "submitContext":
      return `await ${locatorExpr}.click();`;
    case "custom":
    default:
      return `// Custom step: ${String(step.value ?? step.action)}`;
  }
}

/**
 * Generates code for a single test expectation
 */
function generateExpectationCode(expectation: TestExpectation): string {
  if (expectation.selector === undefined) {
    // Handle URL assertions or other selector-less expectations
    switch (expectation.type) {
      case "url-contains":
        return `await expect(page).toHaveURL(new RegExp("${escapeRegex(String(expectation.value ?? ""))}"));`;
      case "url-exact":
        return `await expect(page).toHaveURL("${escapeString(String(expectation.value ?? ""))}");`;
      default:
        return `// Expectation without selector: ${expectation.type}`;
    }
  }

  const locatorExpr = generateLocator(expectation.selector);

  switch (expectation.type) {
    case "visible":
      return `await expect(${locatorExpr}).toBeVisible();`;
    case "not-visible":
      return `await expect(${locatorExpr}).not.toBeVisible();`;
    case "exists":
      return `await expect(${locatorExpr}).toBeAttached();`;
    case "not-exists":
      return `await expect(${locatorExpr}).not.toBeAttached();`;
    case "text":
      return `await expect(${locatorExpr}).toContainText("${escapeString(String(expectation.value ?? ""))}");`;
    case "exact-text":
      return `await expect(${locatorExpr}).toHaveText("${escapeString(String(expectation.value ?? ""))}");`;
    case "value":
      return `await expect(${locatorExpr}).toHaveValue("${escapeString(String(expectation.value ?? ""))}");`;
    case "has-class":
      return `await expect(${locatorExpr}).toHaveClass(new RegExp("${escapeRegex(String(expectation.value ?? ""))}"));`;
    case "not-has-class":
      return `await expect(${locatorExpr}).not.toHaveClass(new RegExp("${escapeRegex(String(expectation.value ?? ""))}"));`;
    case "aria": {
      // aria expectation value format: "label" or "label:value"
      const ariaValue = String(expectation.value ?? "");
      const colonIndex = ariaValue.indexOf(":");
      if (colonIndex === -1) {
        // Just check for attribute existence
        return `await expect(${locatorExpr}).toHaveAttribute("aria-${escapeString(ariaValue)}");`;
      }
      // Check for attribute with specific value
      const ariaName = ariaValue.substring(0, colonIndex);
      const ariaExpectedValue = ariaValue.substring(colonIndex + 1);
      return `await expect(${locatorExpr}).toHaveAttribute("aria-${escapeString(ariaName)}", "${escapeString(ariaExpectedValue)}");`;
    }
    case "snapshot":
      return `await expect(${locatorExpr}).toHaveScreenshot();`;
    case "custom":
    default:
      return `// Custom expectation: ${expectation.type}`;
  }
}

/**
 * Generates test code for a single TestCase
 */
function generateTestCaseCode(
  testCase: TestCase,
  indent: string
): string {
  const lines: string[] = [];

  // Add steps
  if (testCase.steps.length > 0) {
    lines.push(`${indent}// Steps`);
    for (const step of testCase.steps) {
      lines.push(`${indent}${generateStepCode(step)}`);
    }
    lines.push("");
  }

  // Add expectations
  if (testCase.expectations.length > 0) {
    lines.push(`${indent}// Expectations`);
    for (const expectation of testCase.expectations) {
      lines.push(`${indent}${generateExpectationCode(expectation)}`);
    }
  }

  return lines.join("\n");
}

/**
 * Generates a complete Playwright test file from a TestSuite
 *
 * @param testSuite - The TestSuite to generate tests for
 * @returns The complete test file content as a string
 */
export function generatePlaywright(testSuite: TestSuite): string {
  const lines: string[] = [];

  // Add header
  lines.push(HEADER);
  lines.push("");

  // Add imports
  lines.push('import { test, expect } from "@playwright/test";');
  lines.push("");

  // Generate describe block
  lines.push(`test.describe("${escapeString(testSuite.context)}", () => {`);

  // Generate test cases
  for (const testCase of testSuite.cases) {
    lines.push(
      `  test("${escapeString(testCase.scenario)}", async ({ page }) => {`
    );

    // Navigate to route if available
    const route = testCase.route ?? "/";
    lines.push(`    await page.goto("${escapeString(route)}");`);
    lines.push("");

    // Add test code
    const testCode = generateTestCaseCode(testCase, "    ");
    if (testCode.trim().length > 0) {
      lines.push(testCode);
    }

    lines.push("  });");
    lines.push("");
  }

  lines.push("});");

  return lines.join("\n");
}
